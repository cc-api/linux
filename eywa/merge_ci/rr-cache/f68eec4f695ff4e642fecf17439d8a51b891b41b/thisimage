// SPDX-License-Identifier: GPL-2.0+
/*
 * driver/base/topology.c - Populate sysfs with cpu topology information
 *
 * Written by: Zhang Yanmin, Intel Corporation
 *
 * Copyright (C) 2006, Intel Corp.
 *
 * All rights reserved.
 */
#include <linux/mm.h>
#include <linux/cpu.h>
#include <linux/module.h>
#include <linux/hardirq.h>
#include <linux/topology.h>

#define define_id_show_func(name, fmt)					\
static ssize_t name##_show(struct device *dev,				\
			   struct device_attribute *attr, char *buf)	\
{									\
	return sysfs_emit(buf, fmt, topology_##name(dev->id));	\
}

#define define_siblings_show_map(name, mask)				\
static ssize_t name##_show(struct device *dev,				\
			   struct device_attribute *attr, char *buf)	\
{									\
	return cpumap_print_to_pagebuf(false, buf, topology_##mask(dev->id));\
}

#define define_siblings_show_list(name, mask)				\
static ssize_t name##_list_show(struct device *dev,			\
				struct device_attribute *attr,		\
				char *buf)				\
{									\
	return cpumap_print_to_pagebuf(true, buf, topology_##mask(dev->id));\
}

#define define_siblings_show_func(name, mask)	\
	define_siblings_show_map(name, mask);	\
	define_siblings_show_list(name, mask)

define_id_show_func(physical_package_id, "%d\n");
static DEVICE_ATTR_RO(physical_package_id);

define_id_show_func(die_id, "%d\n");
static DEVICE_ATTR_RO(die_id);

<<<<<<<
define_id_show_func(cluster_id);
static DEVICE_ATTR_RO(cluster_id);

define_id_show_func(core_id);
=======
define_id_show_func(core_id, "%d\n");
>>>>>>>
static DEVICE_ATTR_RO(core_id);

define_id_show_func(ppin, "%llx\n");
static DEVICE_ATTR_ADMIN_RO(ppin);

define_siblings_show_func(thread_siblings, sibling_cpumask);
static DEVICE_ATTR_RO(thread_siblings);
static DEVICE_ATTR_RO(thread_siblings_list);

define_siblings_show_func(core_cpus, sibling_cpumask);
static DEVICE_ATTR_RO(core_cpus);
static DEVICE_ATTR_RO(core_cpus_list);

define_siblings_show_func(core_siblings, core_cpumask);
static DEVICE_ATTR_RO(core_siblings);
static DEVICE_ATTR_RO(core_siblings_list);

define_siblings_show_func(cluster_cpus, cluster_cpumask);
static DEVICE_ATTR_RO(cluster_cpus);
static DEVICE_ATTR_RO(cluster_cpus_list);

define_siblings_show_func(die_cpus, die_cpumask);
static DEVICE_ATTR_RO(die_cpus);
static DEVICE_ATTR_RO(die_cpus_list);

define_siblings_show_func(package_cpus, core_cpumask);
static DEVICE_ATTR_RO(package_cpus);
static DEVICE_ATTR_RO(package_cpus_list);

#ifdef CONFIG_SCHED_BOOK
define_id_show_func(book_id);
static DEVICE_ATTR_RO(book_id, "%d\n");
define_siblings_show_func(book_siblings, book_cpumask);
static DEVICE_ATTR_RO(book_siblings);
static DEVICE_ATTR_RO(book_siblings_list);
#endif

#ifdef CONFIG_SCHED_DRAWER
define_id_show_func(drawer_id);
static DEVICE_ATTR_RO(drawer_id, "%d\n");
define_siblings_show_func(drawer_siblings, drawer_cpumask);
static DEVICE_ATTR_RO(drawer_siblings);
static DEVICE_ATTR_RO(drawer_siblings_list);
#endif

#ifdef CONFIG_SMP
static ssize_t priority_show(struct device *dev,
			     struct device_attribute *attr,
			     char *buf)
{
	return sprintf(buf, "%u\n", arch_asym_cpu_priority(dev->id));
}
static DEVICE_ATTR_RO(priority);
#endif

static struct attribute *default_attrs[] = {
	&dev_attr_physical_package_id.attr,
	&dev_attr_die_id.attr,
	&dev_attr_cluster_id.attr,
	&dev_attr_core_id.attr,
	&dev_attr_thread_siblings.attr,
	&dev_attr_thread_siblings_list.attr,
	&dev_attr_core_cpus.attr,
	&dev_attr_core_cpus_list.attr,
	&dev_attr_core_siblings.attr,
	&dev_attr_core_siblings_list.attr,
	&dev_attr_cluster_cpus.attr,
	&dev_attr_cluster_cpus_list.attr,
	&dev_attr_die_cpus.attr,
	&dev_attr_die_cpus_list.attr,
	&dev_attr_package_cpus.attr,
	&dev_attr_package_cpus_list.attr,
#ifdef CONFIG_SCHED_BOOK
	&dev_attr_book_id.attr,
	&dev_attr_book_siblings.attr,
	&dev_attr_book_siblings_list.attr,
#endif
#ifdef CONFIG_SCHED_DRAWER
	&dev_attr_drawer_id.attr,
	&dev_attr_drawer_siblings.attr,
	&dev_attr_drawer_siblings_list.attr,
#endif
<<<<<<<
	&dev_attr_ppin.attr,
=======
#ifdef CONFIG_SMP
	&dev_attr_priority.attr,
#endif
>>>>>>>
	NULL
};

static const struct attribute_group topology_attr_group = {
	.attrs = default_attrs,
	.name = "topology"
};

/* Add/Remove cpu_topology interface for CPU device */
static int topology_add_dev(unsigned int cpu)
{
	struct device *dev = get_cpu_device(cpu);

	return sysfs_create_group(&dev->kobj, &topology_attr_group);
}

static int topology_remove_dev(unsigned int cpu)
{
	struct device *dev = get_cpu_device(cpu);

	sysfs_remove_group(&dev->kobj, &topology_attr_group);
	return 0;
}

static int __init topology_sysfs_init(void)
{
	return cpuhp_setup_state(CPUHP_TOPOLOGY_PREPARE,
				 "base/topology:prepare", topology_add_dev,
				 topology_remove_dev);
}

device_initcall(topology_sysfs_init);

DEFINE_PER_CPU(unsigned long, class_cpu_scale[TOPOLOGY_MAX_CPU_SCALE_CLASSES]);

unsigned long topology_get_class_cpu_scale(unsigned int cpu,
					   unsigned int classid)
{
	if (classid >= TOPOLOGY_MAX_CPU_SCALE_CLASSES) {
		pr_err("invalid classid %u\n", classid);
		/* Return minimum possible capacity value. */
		return 1;
	}

	return per_cpu(class_cpu_scale, cpu)[classid];
}

void topology_set_class_cpu_scale(unsigned int cpu, unsigned int classid,
				  unsigned long capacity)
{
	if (classid >= TOPOLOGY_MAX_CPU_SCALE_CLASSES) {
		pr_err("invalid classid %u\n", classid);
		/* Return minimum possible capacity value. */
		return;
	}

	per_cpu(class_cpu_scale, cpu)[classid] = capacity;
}

DEFINE_PER_CPU(unsigned long, cpu_scale) = SCHED_CAPACITY_SCALE;

void topology_set_cpu_scale(unsigned int cpu, unsigned long capacity)
{
	per_cpu(cpu_scale, cpu) = capacity;
}

static ssize_t cpu_capacity_store(struct device *dev,
				  struct device_attribute *attr,
				  const char *buf,
				  size_t count)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	int c = cpu->dev.id;
	unsigned long new_capacity;
	int ret;

	if (!count)
		return 0;

	ret = kstrtoul(buf, 0, &new_capacity);
	if (ret)
		return ret;

	if (new_capacity > SCHED_CAPACITY_SCALE)
		return -EINVAL;

	topology_set_cpu_scale(c, new_capacity);

	return count;
}

static ssize_t cpu_capacity_show(struct device *dev,
				 struct device_attribute *attr,
				 char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);

	return sysfs_emit(buf, "%lu\n", topology_get_cpu_scale(cpu->dev.id));
}

static DEVICE_ATTR_RW(cpu_capacity);

static int register_cpu_capacity_sysctl(void)
{
	int i;
	struct device *cpu;

	for_each_possible_cpu(i) {
		cpu = get_cpu_device(i);
		if (!cpu) {
			pr_err("%s: too early to get CPU%d device!\n",
			       __func__, i);
			continue;
		}
		device_create_file(cpu, &dev_attr_cpu_capacity);
	}

	return 0;
}
subsys_initcall(register_cpu_capacity_sysctl);
