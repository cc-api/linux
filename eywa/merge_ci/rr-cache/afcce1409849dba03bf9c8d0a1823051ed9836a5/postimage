// SPDX-License-Identifier: MIT
/*
 * Copyright Â© 2021 Intel Corporation
 */
#include <drm/ttm/ttm_bo_driver.h>
#include <drm/ttm/ttm_device.h>

#include "i915_drv.h"
#include "i915_scatterlist.h"
#include "i915_ttm_buddy_manager.h"

#include "intel_region_ttm.h"

extern struct ttm_device_funcs i915_ttm_bo_driver;

/**
 * DOC: TTM support structure
 *
 * The code in this file deals with setting up memory managers for TTM
 * LMEM and MOCK regions and converting the output from
 * the managers to struct sg_table, Basically providing the mapping from
 * i915 GEM regions to TTM memory types and resource managers.
 */

/**
 * intel_region_ttm_device_init - Initialize a TTM device
 * @dev_priv: Pointer to an i915 device private structure.
 *
 * Return: 0 on success, negative error code on failure.
 */
int intel_region_ttm_device_init(struct drm_i915_private *dev_priv)
{
	struct drm_device *drm = &dev_priv->drm;

	return ttm_device_init(&dev_priv->bdev, &i915_ttm_bo_driver,
			       drm->dev, drm->anon_inode->i_mapping,
			       drm->vma_offset_manager, false, false);
}

/**
 * intel_region_ttm_device_fini - Finalize a TTM device
 * @dev_priv: Pointer to an i915 device private structure.
 */
void intel_region_ttm_device_fini(struct drm_i915_private *dev_priv)
{
	ttm_device_fini(&dev_priv->bdev);
}

/*
 * Map the i915 memory regions to TTM memory types. We use the
 * driver-private types for now, reserving TTM_PL_VRAM for stolen
 * memory and TTM_PL_TT for GGTT use if decided to implement this.
 */
static int intel_region_to_ttm_type(struct intel_memory_region *mem)
{
	int type;

	GEM_BUG_ON(mem->type != INTEL_MEMORY_LOCAL);

	type = mem->instance + TTM_PL_PRIV;
	GEM_BUG_ON(type >= TTM_NUM_MEM_TYPES);

	return type;
}

/**
 * intel_region_ttm_init - Initialize a memory region for TTM.
 * @mem: The region to initialize.
 *
 * This function initializes a suitable TTM resource manager for the
 * region, and if it's a LMEM region type, attaches it to the TTM
 * device. MOCK regions are NOT attached to the TTM device, since we don't
 * have one for the mock selftests.
 *
 * Return: 0 on success, negative error code on failure.
 */
int intel_region_ttm_init(struct intel_memory_region *mem)
{
	struct ttm_resource_manager *man;

	man = i915_ttm_buddy_man_init_nodev(resource_size(&mem->region),
					    PAGE_SIZE, false);
	if (IS_ERR(man))
		return PTR_ERR(man);

	ttm_resource_manager_set_used(man, true);
	mem->region_private = man;

	/*
	 * Register only LOCAL memory with the device so that we can
	 * run the mock selftests using the manager.
	 */
	if (mem->type == INTEL_MEMORY_LOCAL) {
		ttm_set_driver_manager(&mem->i915->bdev,
				       intel_region_to_ttm_type(mem),
				       man);
	}

	return 0;
}

/**
 * intel_region_ttm_fini - Finalize a TTM region.
 * @mem: The memory region
 *
 * This functions takes down the TTM resource manager associated with the
 * memory region, and if it was registered with the TTM device,
 * removes that registration.
 */
void intel_region_ttm_fini(struct intel_memory_region *mem)
{
	struct ttm_resource_manager *man = mem->region_private;

	if (mem->type == INTEL_MEMORY_LOCAL) {
		int ret;

		ret = i915_ttm_buddy_man_fini(&mem->i915->bdev,
					      intel_region_to_ttm_type(mem));
		GEM_WARN_ON(ret);
	} else {
		ttm_resource_manager_set_used(man, false);
		i915_ttm_buddy_man_fini_nodev(man);
	}
}

#ifdef CONFIG_DRM_I915_SELFTEST
/**
 * intel_region_ttm_node_alloc - Allocate memory resources from a region
 * @mem: The memory region,
 * @size: The requested size in bytes
 * @flags: Allocation flags
 *
 * This functionality is provided only for callers that need to allocate
 * memory from standalone TTM range managers, without the TTM eviction
 * functionality. Don't use if you are not completely sure that's the
 * case. The returned opaque node can be converted to an sg_table using
 * intel_region_ttm_node_to_st(), and can be freed using
 * intel_region_ttm_node_free().
 *
 * Return: A valid pointer on success, an error pointer on failure.
 */
void *intel_region_ttm_node_alloc(struct intel_memory_region *mem,
				  resource_size_t size,
				  unsigned int flags)
{
	struct ttm_resource_manager *man = mem->region_private;
	struct ttm_place place = {};
	struct ttm_resource res = {};
	struct ttm_buffer_object mock_bo = {};
	int ret;

	res.num_pages = size >> PAGE_SHIFT;
	mock_bo.page_alignment = PAGE_SIZE;
	place.flags = flags;

	ret = man->func->alloc(man, &mock_bo, &place, &res);
	if (ret == -ENOSPC)
		ret = -ENXIO;
	return ret ? ERR_PTR(ret) : res.mm_node;
}

#endif

void intel_region_ttm_node_free(struct intel_memory_region *mem,
				void *node)
{
	struct ttm_resource_manager *man = mem->region_private;
	struct ttm_resource res = {};

	res.mm_node = node;
	man->func->free(man, &res);
}
