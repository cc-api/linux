/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _ASM_X86_TRAPS_H
#define _ASM_X86_TRAPS_H

#include <linux/context_tracking_state.h>
#include <linux/kprobes.h>

#include <asm/debugreg.h>
#include <asm/idtentry.h>
#include <asm/siginfo.h>			/* TRAP_TRACE, ... */
#include <asm/trap_pf.h>

#ifdef CONFIG_X86_64
asmlinkage __visible notrace struct pt_regs *sync_regs(struct pt_regs *eregs);
asmlinkage __visible notrace
struct pt_regs *fixup_bad_iret(struct pt_regs *bad_regs);
void __init trap_init(void);
asmlinkage __visible noinstr struct pt_regs *vc_switch_off_ist(struct pt_regs *eregs);
#endif

extern bool ibt_selftest(void);

#ifdef CONFIG_X86_F00F_BUG
/* For handling the FOOF bug */
void handle_invalid_op(struct pt_regs *regs);
#endif

static inline int get_si_code(unsigned long condition)
{
	if (condition & DR_STEP)
		return TRAP_TRACE;
	else if (condition & (DR_TRAP0|DR_TRAP1|DR_TRAP2|DR_TRAP3))
		return TRAP_HWBKPT;
	else
		return TRAP_BRKPT;
}

extern int panic_on_unrecovered_nmi;

void math_emulate(struct math_emu_info *);

bool fault_in_kernel_space(unsigned long address);

#ifdef CONFIG_VMAP_STACK
void __noreturn handle_stack_overflow(struct pt_regs *regs,
				      unsigned long fault_address,
				      struct stack_info *info);
#endif

static inline void cond_local_irq_enable(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_enable();
}

static inline void cond_local_irq_disable(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
}
/*
 * Define a function type system_interrupt_handler as the element type of
 * the table system_interrupt_handlers.
 *
 * System interrupt handlers don't take any interrupt vector number, or
 * any interrupt error code as arguments, as a system interrupt handler
 * is defined to handle a specific interrupt vector, and no error code
 * is defined for external interrupts. It takes only one argument of type
 * struct pt_regs *.
 */
#define DECLARE_SYSTEM_INTERRUPT_HANDLER(f)	\
	void f (struct pt_regs *regs)
typedef DECLARE_SYSTEM_INTERRUPT_HANDLER((*system_interrupt_handler));

#ifdef CONFIG_X86_64
inline void set_sysvec_handler(unsigned int i, system_interrupt_handler func);
bool is_sysvec_used(unsigned int i);

static inline void sysvec_setup_fred(unsigned int vector, system_interrupt_handler func)
{
	BUG_ON(vector < FIRST_SYSTEM_VECTOR);
	set_sysvec_handler(vector - FIRST_SYSTEM_VECTOR, func);
}
#else
static inline void sysvec_setup_fred(unsigned int vector, system_interrupt_handler func)
{
}
#endif

#define sysvec_install(vector, func) {					\
	sysvec_setup_fred(vector, func);				\
	if (!cpu_feature_enabled(X86_FEATURE_FRED))			\
		alloc_intr_gate(vector, asm_##func);			\
}

int external_interrupt(struct pt_regs *regs);

#endif /* _ASM_X86_TRAPS_H */
