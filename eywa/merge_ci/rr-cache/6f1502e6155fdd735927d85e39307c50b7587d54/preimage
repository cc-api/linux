// SPDX-License-Identifier: GPL-2.0 OR MIT
#include <drm/ttm/ttm_bo_driver.h>
#include <drm/ttm/ttm_device.h>

#include "i915_drv.h"
#include "i915_scatterlist.h"
#include "i915_ttm_buddy_manager.h"

#include "intel_region_ttm.h"

extern struct ttm_device_funcs i915_ttm_bo_driver;

/*
 * This code deals with setting up memory managers for TTM
 * LMEM and MOCK regions and converting the output from
 * the managers to struct sg_table, hiding the details from
 * the rest of the driver.
 */

int intel_region_ttm_device_init(struct drm_i915_private *dev_priv)
{
	struct drm_device *drm = &dev_priv->drm;

	return ttm_device_init(&dev_priv->bdev, &i915_ttm_bo_driver,
			       drm->dev, drm->anon_inode->i_mapping,
			       drm->vma_offset_manager, false, false);
}

void intel_region_ttm_device_fini(struct drm_i915_private *dev_priv)
{
	ttm_device_fini(&dev_priv->bdev);
}

/*
 * Map the i915 memory regions to TTM memory types. We use the
 * driver-private types for now, reserving TTM_PL_VRAM for stolen
 * memory and TTM_PL_TT for GGTT use if decided to implement this.
 */
static int intel_region_to_ttm_type(struct intel_memory_region *mem)
{
	int type;

	GEM_BUG_ON(mem->type != INTEL_MEMORY_LOCAL);

	type = mem->instance + TTM_PL_PRIV;
	GEM_BUG_ON(type >= TTM_NUM_MEM_TYPES);

	return type;
}

int intel_region_ttm_init(struct intel_memory_region *mem)
{
	struct ttm_resource_manager *man;

	man = i915_ttm_buddy_man_init_nodev(resource_size(&mem->region),
					    PAGE_SIZE, false);
	if (IS_ERR(man))
		return PTR_ERR(man);

	ttm_resource_manager_set_used(man, true);
	mem->is_range_manager = false;
	mem->region_private = man;

	/*
	 * Register only LOCAL memory with the device so that we can
	 * run the mock selftests using the manager.
	 */
	if (mem->type == INTEL_MEMORY_LOCAL) {
		ttm_set_driver_manager(&mem->i915->bdev,
				       intel_region_to_ttm_type(mem),
				       man);
	}

	return 0;
}

void intel_region_ttm_fini(struct intel_memory_region *mem)
{
	struct ttm_resource_manager *man = mem->region_private;

	if (mem->type == INTEL_MEMORY_LOCAL) {
		int ret;

		ret = i915_ttm_buddy_man_fini(&mem->i915->bdev,
					      intel_region_to_ttm_type(mem));
		GEM_WARN_ON(ret);
	} else {
		ttm_resource_manager_set_used(man, false);
		i915_ttm_buddy_man_fini_nodev(man);
	}
}

void *intel_region_ttm_node_alloc(struct intel_memory_region *mem,
				  resource_size_t size,
				  unsigned int flags)
{
	struct ttm_resource_manager *man = mem->region_private;
	struct ttm_place place = {};
	struct ttm_resource res = {};
	struct ttm_buffer_object mock_bo = {};
	int ret;

	res.num_pages = size >> PAGE_SHIFT;
<<<<<<<
	mock_bo.page_alignment = PAGE_SIZE;
	place.flags = flags;
=======
	mock_bo.page_alignment = mem->min_page_size;
	place->flags = flags;
>>>>>>>

	ret = man->func->alloc(man, &mock_bo, &place, &res);
	if (ret == -ENOSPC)
		ret = -ENXIO;
	return ret ? ERR_PTR(ret) : res.mm_node;
}

void intel_region_ttm_node_free(struct intel_memory_region *mem,
				void *node)
{
	struct ttm_resource_manager *man = mem->region_private;
	struct ttm_resource res = {};

	res.mm_node = node;
	man->func->free(man, &res);
}
