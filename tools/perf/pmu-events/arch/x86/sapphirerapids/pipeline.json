[
    {
        "BriefDescription": "This event counts the number of floating-point divide instructions executed this cycle. 512-bits divide/SQRT are counted as 1.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb0",
        "EventName": "ARITH.DIVIDER_INST",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "This event counts the number of dividers in loop-stage every cycle. This indicates that the divider is busy and can't accept further operations. The event accounts for all floating-point x87/SSE/AVX* DIV and SQRT instructions.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb0",
        "EventName": "ARITH.DIVIDER_OCCUPANCY",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb0",
        "EventName": "ARITH.FP_DIVIDER_ACTIVE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "This event counts the number of uops executed corresponding to arithmetic FP instructions with at least 1 architecturally masked-out element.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb0",
        "EventName": "ARITH.FP_MASKED_OP",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "This event counts the cycles the integer divider is busy.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb0",
        "EventName": "ARITH.IDIV_ACTIVE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "This event counts the number of integer divide instructions executed this cycle.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb0",
        "EventName": "ARITH.IDIV_INST",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x10"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb0",
        "EventName": "ARITH.INT_DIVIDER_ACTIVE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "All indirect branch instructions retired (excluding RETs. TSX aborts are considered indirect branch).",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc4",
        "EventName": "BR_INST_RETIRED.INDIRECT",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts all indirect branch instructions retired (excluding RETs. TSX aborts is considered indirect branch).",
        "SampleAfterValue": "100003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Mispredicted conditional branch instructions retired.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts mispredicted conditional branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x11"
    },
    {
        "BriefDescription": "Mispredicted non-taken conditional branch instructions retired.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_NTAKEN",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of conditional branch instructions retired that were mispredicted and the branch direction was not taken.",
        "SampleAfterValue": "400009",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "number of branch instructions retired that were mispredicted and taken. Non PEBS",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.COND_TAKEN",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts taken conditional mispredicted branch instructions retired.",
        "SampleAfterValue": "400009",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "All miss-predicted indirect branch instructions retired (excluding RETs. TSX aborts is considered indirect branch).",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts all miss-predicted indirect branch instructions retired (excluding RETs. TSX aborts is considered indirect branch).",
        "SampleAfterValue": "100003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Mispredicted indirect CALL retired.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.INDIRECT_CALL",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts retired mispredicted indirect (near taken) CALL instructions, including both register and memory indirect.",
        "SampleAfterValue": "400009",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Number of near branch instructions retired that were mispredicted and taken.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.NEAR_TAKEN",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts number of near branch instructions retired that were mispredicted and taken.",
        "SampleAfterValue": "400009",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "This event counts the number of mispredicted ret instructions retired. Non PEBS",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc5",
        "EventName": "BR_MISP_RETIRED.RET",
        "PEBS": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "This is a non-precise version (that is, does not use PEBS) of the event that counts mispredicted return instructions retired.",
        "SampleAfterValue": "100007",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Reference cycles when the core is not in halt state.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_TSC_P",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of reference cycles when the core is not in a halt state. The core enters the halt state when it is running the HLT instruction or the MWAIT instruction. This event is not affected by core frequency changes (for example, P states, TM2 transitions) but has the same incrementing frequency as the time stamp counter. This event can approximate elapsed time while the core was not in a halt state. This event has a constant ratio with the CPU_CLK_UNHALTED.REF_XCLK event. It is counted on a dedicated fixed counter, leaving the four (eight when Hyperthreading is disabled) programmable counters available for other events. Note: On all current platforms this event stops counting during 'throttling (TM)' states duty off periods the processor is 'halted'.  The counter update is done at a lower clock rate then the core clock the overflow status bit for this counter may appear 'sticky'.  After the counter has overflowed and software clears the overflow status bit and resets the counter to less than MAX. The reset value to the counter is not clocked immediately so the overflow status bit will flip 'high (1)' and generate another PMI (if enabled) after which the reset value gets clocked into the counter. Therefore, software will get the interrupt, read the overflow status bit '1 for bit 34 while the counter value is less than MAX. Software should ignore this case.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Core crystal clock cycles when the thread is unhalted.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0x3c",
        "EventName": "CPU_CLK_UNHALTED.REF_XCLK",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts core crystal clock cycles when the thread is unhalted.",
        "SampleAfterValue": "25003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Cycles while L2 cache miss demand load is outstanding.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "1",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.CYCLES_L2_MISS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Execution stalls while L1 cache miss demand load is outstanding.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "12",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L1D_MISS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0xc"
    },
    {
        "BriefDescription": "Execution stalls while L2 cache miss demand load is outstanding.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "5",
        "EventCode": "0xa3",
        "EventName": "CYCLE_ACTIVITY.STALLS_L2_MISS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0x5"
    },
    {
        "BriefDescription": "Cycles total of 3 uops are executed on all ports and Reservation Station was not empty.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.3_PORTS_UTIL",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Cycles total of 3 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Cycles total of 4 uops are executed on all ports and Reservation Station was not empty.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.4_PORTS_UTIL",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Cycles total of 4 uops are executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "2000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "Cycles where no uops were executed, the Reservation Station was not empty, the Store Buffer was full and there was no outstanding load.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.EXE_BOUND_0_PORTS",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles during which no uops were executed on all ports and Reservation Station (RS) was not empty.",
        "SampleAfterValue": "1000003",
        "UMask": "0x80"
    },
    {
        "BriefDescription": "Cycles when the memory subsystem has an outstanding load. Increments by 4 for every such cycle.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "4",
        "EventCode": "0xa6",
        "EventName": "EXE_ACTIVITY.LOAD_PENDING_CYCLES",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles when the memory subsystem has an outstanding load. Increments by 4 for every such cycle.",
        "SampleAfterValue": "2000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event DECODE.LCP",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x87",
        "EventName": "ILD_STALL.LCP",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "500009",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Instructions used by decoders during the cycle",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x75",
        "EventName": "INST_DECODED.DECODERS",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "This event counts instructions used by decoders during the cycle.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x75",
        "EventName": "INST_DECODED.UNFUSED",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "2000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Number of all retired NOP instructions.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.ALL_NOPS",
        "PEBScounters": "1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Number of instructions retired. General Counter - architectural event",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.ANY_PEBS",
        "PEBScounters": "1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of X86 instructions retired - an Architectural PerfMon event. Counting continues during hardware interrupts, traps, and inside interrupt handlers. Notes: INST_RETIRED.ANY is counted by a designated fixed counter freeing up programmable counters to count other events. INST_RETIRED.ANY_P is counted by a programmable counter.",
        "SampleAfterValue": "2000003"
    },
    {
        "BriefDescription": "Cycles with less than 10 actually retired instructions.",
        "CollectPEBSRecord": "2",
        "Counter": "1,2,3,4,5,6,7",
        "CounterMask": "31",
        "EventCode": "0xc0",
        "EventName": "INST_RETIRED.TOTAL_CYCLES",
        "Invert": "1",
        "PEBS": "1",
        "PEBScounters": "1,2,3,4,5,6,7",
        "PublicDescription": "Number of cycles using an always true condition applied to  PEBS instructions retired event. (inst_ret&amp;amp;amp;lt; 10)",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles the Backend cluster is recovering after a miss-speculation or a Store Buffer or Load Buffer drain stall.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xad",
        "EventName": "INT_MISC.ALL_RECOVERY_CYCLES",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles the Backend cluster is recovering after a miss-speculation or a Store Buffer or Load Buffer drain stall.",
        "SampleAfterValue": "2000003",
        "UMask": "0x3"
    },
    {
        "BriefDescription": "TBD",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.MBA_STALL",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Stall cycles due to SB/LB drain cycles. SB drain may apply after Nukes, while LB drain applies for HLE senior loads.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.MEM_DRAIN",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles when Resource Allocation Table (RAT) external stall is sent to Instruction Decode Queue (IDQ) for the thread",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.RAT_STALL_CYCLES",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "This event counts the number of cycles during which Resource Allocation Table (RAT) external stall is sent to Instruction Decode Queue (IDQ) for the current thread. This also includes the cycles during which the Allocator is serving another thread.",
        "SampleAfterValue": "1000003",
        "UMask": "0x8"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xad",
        "EventName": "INT_MISC.SMT_STALL",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.128BIT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x13"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe7",
        "EventName": "INT_VEC_RETIRED.256BIT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0xac"
    },
    {
        "BriefDescription": "Loads delayed due to SB blocks, preceding store operations with known addresses but unknown data.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.DATA_UNKNOWN",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "TBD",
        "SampleAfterValue": "100003",
        "UMask": "0x81"
    },
    {
        "BriefDescription": "Load operations delayed due to the store buffer blocks",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_ADDR_BLK",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "TBD",
        "SampleAfterValue": "100003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "counts loads Block-on-STORE block-code (excludes unknown STA)",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_BLOCK",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "This event counts the total number of times when a load gets the Block-on-STORE block code, that is the load is blocked until the colliding store is committed to the cache. This includes total cases as a result of the software (for example, incomplete overlap, load hitting store_unlock, and so on) or hardware restrictions (for example, SbTailHit, limitation in Rotator, and so on). This counter is a super set for all block-on-STORE derived counters.",
        "SampleAfterValue": "100003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_EARLY",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "100003",
        "UMask": "0xa1"
    },
    {
        "BriefDescription": "Loads blocked due to overlapping with a preceding store that cannot be forwarded.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS.STORE_FORWARD",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "Counts the number of times where store forwarding was prevented for a load operation. The most common case is a load blocked due to the address of memory access (partially) overlapping with a preceding uncompleted store. Note: See the table of not supported store forwards in the Optimization Guide.",
        "SampleAfterValue": "100003",
        "UMask": "0x82"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event LD_BLOCKS.ADDRESS_ALIAS",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x03",
        "EventName": "LD_BLOCKS_PARTIAL.ADDRESS_ALIAS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "100003",
        "UMask": "0x84"
    },
    {
        "BriefDescription": "Load dispatches that hit L1D fill buffer (FB) allocated for hardware prefetch.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PRE.HW_PF",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "This event counts all not software-prefetch load dispatches that hit the fill buffer (FB) allocated for the hardware prefetch.",
        "SampleAfterValue": "100003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Counts the number of demand load dispatches that hit L1D fill buffer (FB) allocated for software prefetch.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x4c",
        "EventName": "LOAD_HIT_PREFETCH.SWPF",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "Counts all not software-prefetch load dispatches that hit the fill buffer (FB) allocated for the software prefetch. It can also be incremented by some lock instructions. So it should only be used with profiling so that the locks can be excluded by ASM (Assembly File) inspection of the nearby instructions.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x7f",
        "EventName": "LSD_REPLAY.ABORTS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "100003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles there was a Nuke. Account for both thread-specific and All Thread Nukes.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.NUKE_ASSERTED",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "This event counts both thread-specific (TS) and all-thread (AT) nukes.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Self-modifying code (SMC) detected.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc3",
        "EventName": "MACHINE_CLEARS.SMC",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts self-modifying code (SMC) detected, which causes a machine clear.",
        "SampleAfterValue": "100003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Number of user-level interrupts received.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.ULI_RECEIVED",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "TBD",
        "SampleAfterValue": "400009",
        "UMask": "0x21"
    },
    {
        "BriefDescription": "Number of user-level interrupts sent through SENDUIPI instruction.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.ULI_SENT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "TBD",
        "SampleAfterValue": "400009",
        "UMask": "0x22"
    },
    {
        "BriefDescription": "WRMSR instructions retired",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xe0",
        "EventName": "MISC2_RETIRED.WRMSR",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "TBD",
        "SampleAfterValue": "400009",
        "UMask": "0x23"
    },
    {
        "BriefDescription": "Increments whenever there is an update to the LBR array.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.LBR_INSERTS",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Increments when an entry is added to the Last Branch Record (LBR) array (or removed from the array in case of RETURNs in call stack mode). The event requires LBR enable via IA32_DEBUGCTL MSR and branch type selection via MSR_LBR_SELECT.",
        "SampleAfterValue": "100003",
        "UMask": "0x20"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.MEM_FAULT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "TBD",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.PAUSE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event MISC_RETIRED.PAUSE",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.PAUSE_INST",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x40"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.PT_OVERFLOW",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "101",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts Monitored Region entries. Requires some configuration through Intel PT.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.REGION_ENTRY",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Counts Monitored Region exits. Requires some configuration through Intel PT.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xcc",
        "EventName": "MISC_RETIRED.REGION_EXIT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Resource-related stall cycles",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa2",
        "EventName": "RESOURCE_STALLS.ANY",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts resource-related stall cycles.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa2",
        "EventName": "RESOURCE_STALLS.GIT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Cycles stalled due to no store buffers available. (not including draining form sync).",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa2",
        "EventName": "RESOURCE_STALLS.SB",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts allocation stall cycles caused by the store buffer (SB) being full. This counts cycles that the pipeline back-end blocked uop delivery from the front-end.",
        "SampleAfterValue": "100003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event RS_EMPTY.CYCLES",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa5",
        "EventName": "RS_EVENTS.EMPTY_CYCLES",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event RS_EMPTY.COUNT",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EdgeDetect": "1",
        "EventCode": "0xa5",
        "EventName": "RS_EVENTS.EMPTY_END",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event UOPS_DISPATCHED.PORT_2_3_10",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_2_3_12",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "This event is deprecated. Refer to new event UOPS_DISPATCHED.PORT_5_11",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb2",
        "EventName": "UOPS_DISPATCHED.PORT_5_10",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x20"
    },
    {
        "BriefDescription": "Number of uops executed on the core.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of uops executed from any thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 2 micro-op is executed from any thread on physical core.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "2",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles when at least 2 micro-ops are executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 3 micro-op is executed from any thread on physical core.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "3",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_3",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles when at least 3 micro-ops are executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles at least 4 micro-op is executed from any thread on physical core.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "4",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_GE_4",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles when at least 4 micro-ops are executed from any thread on physical core.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles with no micro-ops executed from any thread on physical core.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CORE_CYCLES_NONE",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles where at least 1 uop was executed per-thread",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Cycles where at least 1 uop was executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles where at least 2 uops were executed per-thread",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "2",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_2",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Cycles where at least 2 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles where at least 4 uops were executed per-thread",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "4",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.CYCLES_GE_4",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Cycles where at least 4 uops were executed per-thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles any memory uop got cancelled as PRF read port could not be allocated. This event counts when at least 1 uop cancellation occurred on any port. There are 10 INT read ports for IEU and another 10 for AGU in GLC. The store data shares the IEU read ports and may be stalled. Cancel result in 2 cycles reschedule penalty for STD memory uops.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.READ_PORT_STALL",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Counts number of cycles no uops were dispatched to be executed on this thread.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xb1",
        "EventName": "UOPS_EXECUTED.STALL_CYCLES",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles during which no uops were dispatched from the Reservation Station (RS) per thread.",
        "SampleAfterValue": "2000003",
        "UMask": "0x1"
    },
    {
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.MRN_LDCHECK",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "Cycles when RAT does not issue Uops to RS for the thread",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xae",
        "EventName": "UOPS_ISSUED.STALL_CYCLES",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles during which the Resource Allocation Table (RAT) does not issue any Uops to the reservation station (RS) for the current thread.",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of Guaranteed retirement slots retired this cycle by any thread",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.CORE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Cycles without actually retired uops.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.STALL_CYCLES",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "This event counts cycles without actually retired uops.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles no executable uops retired",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "1",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.STALL_PERIODS",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "This is a non-precise version (that is, does not use PEBS) of the event that counts cycles without actually retired uops.",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles with less than 10 actually retired uops.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "CounterMask": "10",
        "EventCode": "0xc2",
        "EventName": "UOPS_RETIRED.TOTAL_CYCLES",
        "Invert": "1",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of cycles using always true condition (uops_ret &amp;amp;amp;lt; 16) applied to non PEBS uops retired event.",
        "SampleAfterValue": "1000003",
        "UMask": "0x2"
    }
]