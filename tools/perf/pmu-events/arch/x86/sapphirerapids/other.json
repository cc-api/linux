[
    {
        "BriefDescription": "Number of occurrences where a microcode assist is invoked by hardware.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc1",
        "EventName": "ASSISTS.ANY",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of occurrences where a microcode assist is invoked by hardware Examples include AD (page Access Dirty), FP and AVX related assists.",
        "SampleAfterValue": "100003",
        "UMask": "0x1f"
    },
    {
        "BriefDescription": "Count all other microcode assist beyond FP, AVX_TILE_MIX and A/D assists (counted by their own sub-events). This includes assists at uop writeback like AVX* load/store (non-FP) assists, Null Assist in SNC (due to lack of FP precision format convert with FMA3x3 uarch) or assists generated by ROB (like assists to due to Missprediction for FSW register - fixed in SNC)",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc1",
        "EventName": "ASSISTS.HARDWARE",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "100003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xc1",
        "EventName": "ASSISTS.PAGE_FAULT",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "1000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x28",
        "EventName": "CORE_POWER.LICENSE_1",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "200003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x28",
        "EventName": "CORE_POWER.LICENSE_2",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "200003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x28",
        "EventName": "CORE_POWER.LICENSE_3",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "200003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x28",
        "EventName": "CORE_POWER.LICENSE_4",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "200003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x28",
        "EventName": "CORE_POWER.LICENSE_6",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "200003",
        "UMask": "0x40"
    },
    {
        "BriefDescription": "Counts the cycles where the AMX (Advance Matrix Extension) unit is busy performing an operation.",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xb7",
        "EventName": "EXE.AMX_BUSY",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "2000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Cycles while L1 cache miss demand load is outstanding.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "2",
        "EventCode": "0x47",
        "EventName": "MEMORY_ACTIVITY.CYCLES_L1D_MISS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Execution stalls while L1 cache miss demand load is outstanding.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "3",
        "EventCode": "0x47",
        "EventName": "MEMORY_ACTIVITY.STALLS_L1D_MISS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0x3"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "5",
        "EventCode": "0x47",
        "EventName": "MEMORY_ACTIVITY.STALLS_L2_MISS",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0x5"
    },
    {
        "BriefDescription": "Counts demand instruction fetches and L1 instruction cache prefetches that  were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_CODE_RD.SNC_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x708000004",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand data reads that have any type of response.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_DATA_RD.ANY_RESPONSE",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x10001",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand data reads that resulted in a snoop hit a modified line in another core's caches which forwarded the data.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HITM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x10003C0001",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand data reads that resulted in a snoop that hit in another core, which did not forward the data.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HIT_NO_FWD",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x4003C0001",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand data reads that resulted in a snoop hit in another core's caches which forwarded the unmodified data to the requesting core.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_DATA_RD.L3_HIT.SNOOP_HIT_WITH_FWD",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x8003C0001",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand data reads that were supplied by DRAM attached to this socket, unless in Sub NUMA Cluster(SNC) Mode.  In SNC Mode counts only those DRAM accesses that are controlled by the close SNC Cluster.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_DATA_RD.LOCAL_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x104000001",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand data reads that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_DATA_RD.SNC_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x708000001",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that have any type of response.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_RFO.ANY_RESPONSE",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x3F3FFC0002",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that resulted in a snoop hit a modified line in another core's caches which forwarded the data.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_RFO.L3_HIT.SNOOP_HITM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x10003C0002",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts demand reads for ownership (RFO) requests and software prefetches for exclusive ownership (PREFETCHW) that were supplied by DRAM on a distant memory controller of this socket when the system is in SNC (sub-NUMA cluster) mode.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.DEMAND_RFO.SNC_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x708000002",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts hardware prefetches to the L3 only that  were not supplied by the local socket's L1, L2, or L3 caches and the cacheline was homed in a remote socket.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.HWPF_L3.REMOTE",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x90002380",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts all data read, code read and RFO requests including demands and prefetches to the core caches (L1 or L2) that were supplied by DRAM attached to this socket, unless in Sub NUMA Cluster(SNC) Mode.  In SNC Mode counts only those DRAM accesses that are controlled by the close SNC Cluster.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.READS_TO_CORE.LOCAL_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x104004477",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts all data read, code read and RFO requests including demands and prefetches to the core caches (L1 or L2) that were supplied by DRAM attached to this socket, whether or not in Sub NUMA Cluster(SNC) Mode.  In SNC Mode counts DRAM accesses that are controlled by the close or distant SNC Cluster.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.READS_TO_CORE.LOCAL_SOCKET_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x70C004477",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts all data read, code read and RFO requests including demands and prefetches to the core caches (L1 or L2) that were supplied by PMM attached to this socket, whether or not in Sub NUMA Cluster(SNC) Mode.  In SNC Mode counts PMM accesses that are controlled by the close or distant SNC Cluster.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.READS_TO_CORE.LOCAL_SOCKET_PMM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x700C04477",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts all data read, code read and RFO requests including demands and prefetches to the core caches (L1 or L2) that were not supplied by the local socket's L1, L2, or L3 caches and were supplied by a remote socket.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.READS_TO_CORE.REMOTE",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x3F33004477",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts all data read, code read and RFO requests including demands and prefetches to the core caches (L1 or L2) that were supplied by DRAM attached to another socket.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.READS_TO_CORE.REMOTE_DRAM",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x730004477",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Counts streaming stores that have any type of response.",
        "Counter": "0,1,2,3",
        "EventCode": "0x2A,0x2B",
        "EventName": "OCR.STREAMING_WR.ANY_RESPONSE",
        "MSRIndex": "0x1a6,0x1a7",
        "MSRValue": "0x10800",
        "Offcore": "1",
        "PublicDescription": "Offcore response can be programmed only with a specific pair of event select and counter MSR, and with specific event codes and predefine mask bit value in a dedicated MSR to specify attributes of the offcore transaction.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Cycles when Reservation Station (RS) is empty for the thread.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa5",
        "EventName": "RS_EMPTY.CYCLES",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts cycles during which the reservation station (RS) is empty for this logical processor.",
        "SampleAfterValue": "1000003",
        "UMask": "0x7"
    },
    {
        "BriefDescription": "Number of PREFETCHNTA instructions executed.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x40",
        "EventName": "SW_PREFETCH_ACCESS.NTA",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "Counts the number of PREFETCHNTA instructions executed.",
        "SampleAfterValue": "100003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "Number of PREFETCHW instructions executed.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x40",
        "EventName": "SW_PREFETCH_ACCESS.PREFETCHW",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "Counts the number of PREFETCHW instructions executed.",
        "SampleAfterValue": "100003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "Number of PREFETCHT0 instructions executed.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x40",
        "EventName": "SW_PREFETCH_ACCESS.T0",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "Counts the number of PREFETCHT0 instructions executed.",
        "SampleAfterValue": "100003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "Number of PREFETCHT1 or PREFETCHT2 instructions executed.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "EventCode": "0x40",
        "EventName": "SW_PREFETCH_ACCESS.T1_T2",
        "PEBScounters": "0,1,2,3",
        "PublicDescription": "Counts the number of PREFETCHT1 or PREFETCHT2 instructions executed.",
        "SampleAfterValue": "100003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TMA slots where no uops were being issued due to lack of back-end resources.",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BACKEND_BOUND_SLOTS",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Number of slots in TMA method where no micro-operations were being issued from front-end to back-end of the machine due to lack of back-end resources.",
        "SampleAfterValue": "10000003",
        "UMask": "0x2"
    },
    {
        "BriefDescription": "TMA slots wasted due to incorrect speculations.",
        "CollectPEBSRecord": "2",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BAD_SPEC_SLOTS",
        "PublicDescription": "Number of slots of TMA method that were wasted due to incorrect speculation. It covers all types of control-flow or data-related mis-speculations.",
        "SampleAfterValue": "10000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TMA slots wasted due to incorrect speculation by branch mispredictions",
        "CollectPEBSRecord": "2",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.BR_MISPREDICT_SLOTS",
        "PublicDescription": "Number of TMA slots that were wasted due to incorrect speculation by (any type of) branch mispredictions. This event estimates number of specualtive operations that were issued but not retired as well as the out-of-order engine recovery past a branch misprediction.",
        "SampleAfterValue": "10000003",
        "UMask": "0x8"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.MEMORY_BOUND_SLOTS",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "SampleAfterValue": "10000003",
        "UMask": "0x10"
    },
    {
        "BriefDescription": "TMA slots available for an unhalted logical processor. Fixed counter - architectural event",
        "CollectPEBSRecord": "2",
        "Counter": "Fixed counter 3",
        "EventName": "TOPDOWN.SLOTS",
        "PEBScounters": "35",
        "PublicDescription": "Number of available slots for an unhalted logical processor. The event increments by machine-width of the narrowest pipeline as employed by the Top-down Microarchitecture Analysis method (TMA). The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core. Software can use this event as the denominator for the top-level metrics of the TMA method. This architectural event is counted on a designated fixed counter (Fixed Counter 3).",
        "SampleAfterValue": "10000003",
        "UMask": "0x4"
    },
    {
        "BriefDescription": "TMA slots available for an unhalted logical processor. General counter - architectural event",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3,4,5,6,7",
        "EventCode": "0xa4",
        "EventName": "TOPDOWN.SLOTS_P",
        "PEBScounters": "0,1,2,3,4,5,6,7",
        "PublicDescription": "Counts the number of available slots for an unhalted logical processor. The event increments by machine-width of the narrowest pipeline as employed by the Top-down Microarchitecture Analysis method. The count is distributed among unhalted logical processors (hyper-threads) who share the same physical core.",
        "SampleAfterValue": "10000003",
        "UMask": "0x1"
    },
    {
        "BriefDescription": "TBD",
        "CollectPEBSRecord": "2",
        "Counter": "0,1,2,3",
        "CounterMask": "1",
        "EventCode": "0x2d",
        "EventName": "XQ.FULL_CYCLES",
        "PEBScounters": "0,1,2,3",
        "SampleAfterValue": "1000003",
        "UMask": "0x1"
    }
]